#!/usr/bin/env ruby

require '3scale_toolbox/cli'

require 'optparse'
require 'pry'

options = {}

parser = OptionParser.new do |parser|
  parser.banner = '3scale update <command> [options]'

  parser.on('-s', '--source SOURCE', "Source") do |domain|
    options[:source] = domain
  end

  parser.on('-d', '--destination DESTINATION', "Destination") do |domain|
    options[:destination] = domain
  end

  parser.on('-t', '--target-system-name TARGET_SYSTEM_NAME', 'Target system name') do |name|
    options[:target_system_name] = name
  end

  parser.on('-h', '--help', 'Prints this help') do
    puts parser
    puts
    puts 'Available Commands:', ['service <service_id>', 'help']
    exit
  end
end

print_help = ->(error = nil) do
  if error
    puts "Error: #{error}"
    puts
  end
  parser.parse(['--help'])
end


parser.parse!

def compare_hashes(first, second, keys)
  keys.map{ |key| first.fetch(key) } == keys.map{ |key| second.fetch(key) }
end

def fetch_option(options, key)
  options.fetch(key) { raise OptionParser::MissingArgument, key }
end

def provider_key_from_url(url)
  url[/\w*@/][0..-2]
end

def endpoint_from_url(url)
  url.sub /\w*@/, ''
end

def target_service_params(source, system_name)
  {
    name:        source['name'],
    system_name: system_name,
    end_user_registration_required: source['end_user_registration_required']
  }.reject { |key, value| !value }
end

case (command = ARGV.shift)
  when 'service'
    source      = fetch_option options, :source
    destination = fetch_option options, :destination
    system_name = options[:target_system_name]
    
    require '3scale/api'

    service_id = ARGV.shift or raise OptionParser::MissingArgument, 'service_id'

    source_client = ThreeScale::API.new(
      endpoint:     endpoint_from_url(source), 
      provider_key: provider_key_from_url(source)
    )
    client        = ThreeScale::API.new(
      endpoint:     endpoint_from_url(destination), 
      provider_key: provider_key_from_url(destination)
    )
    
    service = source_client.show_service(service_id)
  
    service_target_id = client.list_services.find { |s| s["system_name"] == system_name }["id"]

    target = client.update_service(target_service_params(service, system_name), service_target_id)

    raise "Service has not been saved. Errors: #{target['errors']}" unless target['errors'].nil?

    puts "updating service id #{service_target_id}"

    proxy = source_client.show_proxy(service_id)
    client.update_proxy(service_target_id, proxy)
    puts "updated proxy of #{service_target_id} to match the source"

    metrics = source_client.list_metrics(service_id)
    metrics_copies = client.list_metrics(service_target_id)

    hits = metrics.find{ |metric| metric['system_name'] == 'hits' } or raise 'missing hits metric'
    hits_target = metrics_copies.find{ |metric| metric['system_name'] == 'hits' } or raise 'missing hits metric'

    methods = source_client.list_methods(service_id, hits['id'])
    methods_copies = client.list_methods(service_target_id, hits_target['id'])

    puts "source service hits metric #{hits['id']} has #{methods.size} methods"
    puts "target service hits metric #{hits_target['id']} has #{methods_copies.size} methods"

    missing_methods = methods.reject { |method|  methods_copies.find{|target| compare_hashes(method, target, ['system_name']) } }

    puts "creating #{missing_methods.size} missing methods on target service"
    missing_methods.each do |method|
      target = { friendly_name: method['friendly_name'], system_name: method['system_name'] }
      client.create_method(service_target_id, hits_target['id'], target)
    end

    metrics_copies = client.list_metrics(service_target_id)

    puts "source service has #{metrics.size} metrics"
    puts "target service has #{metrics_copies.size} metrics"

    missing_metrics = metrics.reject { |metric| metrics_copies.find{|target| compare_hashes(metric, target, ['system_name']) } }

    missing_metrics.map do |metric|
      metric.delete('links')
      client.create_metric(service_target_id, metric)
    end

    puts "created #{missing_metrics.size} metrics on the target service"

    plans = source_client.list_service_application_plans(service_id)
    plan_copies = client.list_service_application_plans(service_target_id)

    puts "source service has #{plans.size} application plans "
    puts "target service has #{plan_copies.size} application plans"

    missing_application_plans = plans.reject { |plan| plan_copies.find{|target| plan.fetch('system_name') == target.fetch('system_name') } }

    puts "target service missing #{missing_application_plans.size} application plans"

    missing_application_plans.each do |plan|
      plan.delete('links')
      plan.delete('default') # TODO: handle default planÂ§

      if plan.delete('custom') # TODO: what to do with custom plans?
        puts "skipping custom plan #{plan}"
      else
        client.create_application_plan(service_target_id, plan)
      end
    end

    application_plan_mapping = client.list_service_application_plans(service_target_id).map do |plan_target|
      plan = plans.find{|plan| plan.fetch('system_name') == plan_target.fetch('system_name') }

      [plan['id'], plan_target['id']]
    end


    metrics_mapping = client.list_metrics(service_target_id).map do |target|
      metric = metrics.find{|metric| metric.fetch('system_name') == target.fetch('system_name') }
      metric ||= {}

      [metric['id'], target['id']]
    end.to_h

    puts "destroying all mapping rules of the target which have been created by default"
    client.list_mapping_rules(service_target_id).each do |mapping_rule|
      client.delete_mapping_rule(service_target_id, mapping_rule['id'])
    end

    mapping_rules = source_client.list_mapping_rules(service_id)
    mapping_rules_target = client.list_mapping_rules(service_target_id)

    puts "the source service has #{mapping_rules.size} mapping rules"
    puts "the target has #{mapping_rules_target.size} mapping rules"

    unique_mapping_rules_target = mapping_rules_target.dup

    missing_mapping_rules = mapping_rules.reject do |mapping_rule|
      matching_metric = unique_mapping_rules_target.find do |target|
        compare_hashes(mapping_rule, target, %w(pattern http_method delta)) &&
            metrics_mapping.fetch(mapping_rule.fetch('metric_id')) == target.fetch('metric_id')
      end

      unique_mapping_rules_target.delete(matching_metric)
    end

    puts "missing #{missing_mapping_rules.size} mapping rules"

    missing_mapping_rules.each do |mapping_rule|
      mapping_rule.delete('links')
      mapping_rule['metric_id'] = metrics_mapping.fetch(mapping_rule.delete('metric_id'))
      client.create_mapping_rule(service_target_id, mapping_rule)
    end
    puts "created #{missing_mapping_rules.size} mapping rules"

    puts "extra #{unique_mapping_rules_target.size} mapping rules"
    puts unique_mapping_rules_target.each{|rule| rule.delete('links') }

    application_plan_mapping.each do |source_id, target_id|
      limits = source_client.list_application_plan_limits(source_id)
      limits_target = client.list_application_plan_limits(target_id)

      missing_limits = limits.reject { |limit| limits_target.find{|limit_target| limit.fetch('period') == limit_target.fetch('period') } }

      missing_limits.each do |limit|
        limit.delete('links')
        client.create_application_plan_limit(target_id, metrics_mapping.fetch(limit.fetch('metric_id')), limit)
      end
      puts "target application plan #{target_id} is missing #{missing_limits.size} from the source plan #{source_id}"
    end
  when 'help'
    print_help.call
  when nil
    print_help.call("missing subcommand")
  else
    print_help.call("unknown command #{command}")
end
